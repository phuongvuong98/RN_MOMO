{"version":3,"file":"BackgroundFetch.js","sourceRoot":"","sources":["../src/BackgroundFetch.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,WAAW,MAAM,mBAAmB,CAAC;AACjD,OAAO,EAAE,mBAAmB,EAAE,MAAM,kBAAkB,CAAC;AACvD,OAAO,EAAE,QAAQ,EAAE,kBAAkB,EAAE,MAAM,kBAAkB,CAAC;AAEhE,MAAM,EAAE,mBAAmB,EAAE,GAAG,kBAAkB,CAAC;AAEnD,IAAK,qBAIJ;AAJD,WAAK,qBAAqB;IACxB,qEAAU,CAAA;IACV,uEAAW,CAAA;IACX,qEAAU,CAAA;AACZ,CAAC,EAJI,qBAAqB,KAArB,qBAAqB,QAIzB;AAED,IAAK,qBAIJ;AAJD,WAAK,qBAAqB;IACxB,qEAAU,CAAA;IACV,6EAAc,CAAA;IACd,2EAAa,CAAA;AACf,CAAC,EAJI,qBAAqB,KAArB,qBAAqB,QAIzB;AAQD,MAAM,CAAC,KAAK,UAAU,cAAc;IAClC,IAAI,QAAQ,CAAC,EAAE,KAAK,KAAK,EAAE;QACzB,OAAO,qBAAqB,CAAC,SAAS,CAAC;KACxC;IACD,OAAO,mBAAmB,CAAC,cAAc,EAAE,CAAC;AAC9C,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,uBAAuB,CAAC,eAAuB;IACnE,IAAI,QAAQ,CAAC,EAAE,KAAK,KAAK,EAAE;QACzB,OAAO;KACR;IACD,MAAM,mBAAmB,CAAC,uBAAuB,CAAC,eAAe,CAAC,CAAC;AACrE,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,iBAAiB,CAAC,QAAgB,EAAE,UAAkC,EAAE;IAC5F,IAAI,CAAC,mBAAmB,CAAC,iBAAiB,EAAE;QAC1C,MAAM,IAAI,mBAAmB,CAAC,iBAAiB,EAAE,mBAAmB,CAAC,CAAA;KACtE;IACD,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;QACxC,MAAM,IAAI,KAAK,CACb,SAAS,QAAQ,2FAA2F,CAC7G,CAAC;KACH;IACD,MAAM,mBAAmB,CAAC,iBAAiB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;AACjE,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,mBAAmB,CAAC,QAAgB;IACxD,IAAI,CAAC,mBAAmB,CAAC,mBAAmB,EAAE;QAC5C,MAAM,IAAI,mBAAmB,CAAC,iBAAiB,EAAE,qBAAqB,CAAC,CAAA;KACxE;IACD,MAAM,mBAAmB,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;AAC1D,CAAC;AAED,OAAO,EACL,qBAAqB,IAAI,MAAM,EAC/B,qBAAqB,IAAI,MAAM,GAChC,CAAC","sourcesContent":["import * as TaskManager from 'expo-task-manager';\nimport { UnavailabilityError } from '@unimodules/core';\nimport { Platform, NativeModulesProxy } from '@unimodules/core';\n\nconst { ExpoBackgroundFetch } = NativeModulesProxy;\n\nenum BackgroundFetchResult {\n  NoData = 1,\n  NewData = 2,\n  Failed = 3,\n}\n\nenum BackgroundFetchStatus {\n  Denied = 1,\n  Restricted = 2,\n  Available = 3,\n}\n\ninterface BackgroundFetchOptions {\n  minimumInterval?: number;\n  stopOnTerminate?: boolean;\n  startOnBoot?: boolean;\n}\n\nexport async function getStatusAsync(): Promise<BackgroundFetchStatus | null> {\n  if (Platform.OS !== 'ios') {\n    return BackgroundFetchStatus.Available;\n  }\n  return ExpoBackgroundFetch.getStatusAsync();\n}\n\nexport async function setMinimumIntervalAsync(minimumInterval: number): Promise<void> {\n  if (Platform.OS !== 'ios') {\n    return;\n  }\n  await ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n}\n\nexport async function registerTaskAsync(taskName: string, options: BackgroundFetchOptions = {}): Promise<void> {\n  if (!ExpoBackgroundFetch.registerTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync')\n  }\n  if (!TaskManager.isTaskDefined(taskName)) {\n    throw new Error(\n      `Task '${taskName}' is not defined. You must define a task using TaskManager.defineTask before registering.`\n    );\n  }\n  await ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n}\n\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync')\n  }\n  await ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n}\n\nexport {\n  BackgroundFetchResult as Result,\n  BackgroundFetchStatus as Status,\n};\n"]}